
### Algorithm

https://leetcode.com/problems/climbing-stairs/

楼梯走法问题，把这一题单列出来，是因为非常有意义，在面试的时候居然遇到了这个问题。

面试当时居然我去推到公式，面试官说太慢了，给你点提示，你从最后一阶楼梯开始思考，到达最后一阶楼梯的方法有多少种？

带着这个提示推导出： f(n) = f(n-1) + f(n-2),熟悉的模样。

典型的动态规划，局部最优解，从一个节点的状态得到公式。

```
class Solution {
public:
    int climbStairs(int n) {
        if(n==1) return 1;
        if(n==2) return 2;
        int f1 = 1,f2 = 2,f3 = 0;
        for(int i = 2 ; i < n; i++)
        {
            f3 = f1 + f2;
            f1 = f2;
            f2 = f3;
        }
        return f3;
    }
};
```
### Review

https://www.tldp.org/LDP/tlk/kernel/processes.html

一篇关于进程的文章，看起来很全面，文章很长。这篇文章主要讲述了进程是什么以及在linx中进程是如何被创建、管理以及销毁的。

进程在操作系统中执行任务。一个程序就是一些列存储在磁盘上的机器代码指令和数据集合，因此它可以看成一个被动的实体。一个进程呢就可以看做是一个正在运行的程序。

进程是一个不断在变化的玩意，因为代码在不断的执行。一个进程不仅包含代码指令和数据，同时在一个进程栈中还有一些临时的数据比如参数，返回地址以及保存的变量。除了上面所说的，进程还包含着计数器和cpu寄存器。正在运行的程序或者说进程包含了所有微处理器中的活动。Linux 是一个多进程的操作系统，每个进程都是独立的，有他们自己的权限和任务。每个进程都在自己的虚拟地址空间中运行，因此他们在没有安全的内核保障机制下是不能够相互作用的。所以，一个进程挂掉之后，也不会影响到另外一个进程。

在一个进程多的生命周期中，它会用来很多的资源，诸如使用cpu资源来执行机器指令，使用内存来存储产生的数据。同时也会通过文件系统来打开文件，直接或者间接的打开其他设备。因为Linux是一个多进程的系统，所以为了避免单个进程过多的霸占CPU资源或者内存资源，Linux系统本身必须明确以及跟踪好自己的资源情况，这样能够协调好多个进程对资源的使用，起到公平公正的作用。

在一个多进程的操作系统中，CPU资源总是最珍贵的。因此，在多进程的任务中，如果CPU资源不够的情况下，没有获取CPU资源的进程就必须要等待。在这个等待的进程队列中，Linux使用调度器来决定下个该使用CPU资源的进程，调度器使用一系列的调度策略来确保进程的相对公平。

4.1 进程

Linux 管理着所有的它的进程，每个进程都有一个task_struct 结构体来表示。系统中用指针数组来存储所有的进程，这意味着Linux的进程是有限制的，它的大小是默认的512。每当一个进程被创建的时候，一个新的task_struct结构体被创建并且被添加到task队列，为了方便找到当前正在运行的进程，有一个
current的指针专门来记录正在运行的进程。

Linux不仅支持普通的进程也支持实时的进程。Linux调度器会对这些实时进程有更积极的策略。task_struct 结构体非常庞大和复杂，以下是一些字段以及功能：

State 描述进程的状态

Scheduling Information  调度信息，操作系统依据此信息进行调度

Identifiers 每个进程都有自己的标识符，标识符不是进程数组的下标，仅仅是一个数字，进程除了有自己的标识符外，还有用户标识符合用户组标识符，用来代码进程的访问权限

Inter-Process Communication 进程间通信

Links Linux下的进程都不是孤立存在的，除了init进程外，所有的进程都有一个父进程。新的进程并不是被创建出来的，而是被拷贝甚至是克隆出来的。每个进行用指针和它的父进程、兄弟进程以及子进程保持着联系。通常我们可以用pstree命令来看到进程间的关系
此外，所有的init进程的子进程和init进程都是双向链接的。这样有利于系统迅速找到所有的进程以支持类似与ps和kill的命令

Times and Timers 内核会一直跟踪中进程的创建时间以及进程在它的生命周期中消耗的cpu时间。每个时钟周期，Linux会更新每个进程所花费时间在用户态和内核态。
Linux同时指定间隔的定时器，进程可以通过调用系统函数来给自己设置定时器，这些定时器可以一次性设定，也可以间歇性设定。

File system 进行在按照它们的意愿打开文件的同时，在进程的结构体中会有指针指向这些文件的描述符以及另外的指针指向VFS的两个节点。每个VFS节点存储了文件或者目录在文件系统中唯一的描述符，并且提供了唯一的接口给下层的文件系统。

Virtual memory 绝大多数的线程有虚拟内存（内核线程和守护进程除外），内核必须记录虚拟内存和实际内存是如何对应的

Processor Specific Context 处理器的上下文切换，进程可以认为是系统当前状态的总和。无论何时，当一个进程在运行的时候，它会使用cpu寄存器、堆栈等。这就是进程的环境，当一个进程被挂起的时候，它此时的cpu环境信息将会被保存到进程结构体中，以便下次进程恢复执行时恢复该进程的环境

4.2  Identifiers 

Linux以及类Linux的操作系统通常使用用户和组的标识符来为系统文件表明访问权限。
在进程的结构体中有四组标识符：

uid，gid 进程所代表的用户和用户组

effective uid and gid 有些程序会在启动的时候将执行者的用户和用户组改成自己的。这些程序就是我们所说的设置用户ID的程序，这些程序有的时候是有用的，因为这是一种对服务器的保护，特别是那些代表别人运行的程序，比如是网络守护进程。effective uid来自程序本身设置的而uid，gid使它们本身的。内核在进行权限检查的时候，则会检查effective uid

file system uid and gid 和effective uid and gid 相似，主要是用来检查文件的访问权限。

saved uid and gid 通过系统调用的时候更改进程的uid和gid，需要通过它们记录原来的uid和gid。

4.3 调度

所有的进程都是运行在用户态和内核态的。底层硬件是如何支持这两种模式之间的切换是不同的，但总的来说都是安全的机制。用户模式下相比内核模式下只有很少的权限。每次进程使用一个系统调用让自己从用户态到内核态。此刻，内核代表进程运行。在Linux中，进程不会枪占当前正在运行的线程。每个进程在等待其他资源是会放弃cpu资源。如 一个进程也许在等待一个字符从文件中读取，这个等待发生在内核的系统调用，进程使用库函数进行文件的打开并调用系统函数进行读取。在这种情况下等待的进程会被挂起，另外的急需cpu的进程将被选择去运行。

进程总是进行系统调用因此总是需要进行等待。虽然如此，如果一个进程在它进入等待前也有可能耗费了大量的cpu时间，因此Linux为了更加公平的对待每个进程，linux使用预先调度的策略。在这种策略下，每个进程只允许运行一小段时间，如200ms，当该进程的时候耗费完的时候，另外一个线程就会被选取运行。这个小的时间量就是我们所说的时间片。

调度系统必须从可运行的进程中选取最值得运行的程序。

一个可运行的线程是一个万事俱备只欠cpu的线程。Linux使用一个简单的基于优先级的调度算法来选择要运行的进程。当调度器选择一个新的进程要运行的时候，系统会保存当前进程的运行环境以便后面进行恢复。对于调度器来说，为了公正的分配cpu时间，每个可运行的进程都会记录以下信息用于辅助调度器做出决策：

policy  Linux中的调度策略，有两种的Linux进程一种是普通的另一种是实时的。实时的的进程有更高的优先级相对于其他进程。如果有一个准备好的实时进程去运行，它将总会运行的很快。实时进程可以有两种策略 round robin 和 first in first out。round robin中每个可运行的实时进程按照顺序运行，first in first out中调度每个可运行的线程按照顺序运行。

priority 优先级，每个线程的优先级。也是每个进程运行的时候能能够运行的时间。优先级可以通过系统调用和renice命令来修改。

rt_priority Linux支持实时进程因此调度器对这些实时进程有更高的优先级。这个字段允许调度器给每个实时进程的一个相对的优先级。实时进程的优先级也可以通过系统调用来更改。

counter 这是进程允许运行的时间量。进程每次运行的时候改值被设置成为了优先级的值然后随着每个时钟周期递减。

kernel work 

Current process 
当前进程必须比其他进程优先选择去运行
如果当前进程的调度策略是round robin那么它将会被放到运行队列的末尾
如果任务是可中断的并且已经接收到一个信号那么它的状态将会变成RUNNING
如果当前进程的时间片用光的时候，它会进入running状态
当进程是running状态的话，它会保持在改状态 
如果进程即不是处于running状态也不处于interruptible状态，那么它将从运行队列中移除。这意味着它们将不会被调度器选中作为最想被运行的进程。

Process selection 

调度器在找寻最想被执行的进程的时候，如果这个时候队列中有实时进程。那么这些实时进程将会有更高的权重得到调度器的青睐。对于普通的进程来说，这个权重就是它的counter字段，而对于实时线程来说这个权重就是counter+1000。这意味着如果有可运行状态的实时进程，那么它们将总会优先那么普通进程。当前进程如果消耗了一些时间片，那么如果队列中有处于同一优先级的进程的话，当前进程处于劣势。在一个队列中，如果多个进程处于相同的优先级，那么应该选择距离最近的。当前进程将会被放到队列的末尾。在一个拥有相同优先级的多进程平衡系统中，每个进程将会按照次序运行。这就是众所周知的Round Robin调度。然而，那些等待资源的进程将会被移除队伍。


Swap processes

如果最想被运行的进程不是当前进程。当前进程必须被挂起并且新的进程去运行。当一个进程正在运行那么它将使用寄存器和物理内存。每次它进程调用程序它将传递参数在寄存器而且可能使用到栈去存储返回地址。因此，当调度器运行的时候，它是运行在当前进程的环境中。它将处于一个特权的模式，内核模式。但是它仍然是当前的进程在运行。当这个进程被挂起的时候，所有它的机器状态，包括程序的计数器和所有进程的寄存器必须被保存在进程的task_struct 结构体中。因此，所有机器状态将被加载随着下一个进程的运行。这是一个系统环境依赖，并不需要cpu来参与，但是通常需要一些硬件帮助。

这个进程环境交换发生在调度器的最后。因此，前一个进程保存的上下文就是系统硬件的一个快照，事实上就是调度器对该进程在此次操作中的最后操作。同样当一个新的进程被加载之后，当运行到最后的时候，他的环境信息也将保存。

如果前一个进程或者新的进程使用了虚拟内存，那么系统的页表可能需要被刷新。再一次，这个操作和具体的体系架构有关。像Alpha AXP，在使用转换查找表或者缓存页
表的时候，必须刷新那些属于上一个缓存的页表条目。

4.3.1  Scheduling in Multiprocessor Systems

应该是一篇很早的文章吧，作者说linux中具有多核的操作系统是很少见的，但是现在已经有很多工作促使linux成为一个多进程处理的操作系统。也就是说，他能够平衡各个cpu的工作量。这种平衡是最明显的在调度器中。

在一个多处理器系统中，我们希望多有的处理器都在不断的去执行进程。每个进程在耗尽自己的时间片并且等待资源的时候，它们分别调用调度器。我们首先要注意到在一个SMP系统中并非只有一个空闲的进程。在一个单核的操作系统中，选择一个空闲的进程就是task向量中的第一个。在一个SMP系统中，每个cpu都有一个空闲的线程，而且可能有多个空闲的cpu。此外，每个cpu有一个当前的进程，因此SMP系统中必须必须为每个处理器跟踪记录空闲进程。

在一个SMP系统中，每个进程结构体包含着当前正在运行它的cpu的编号以及上一次运行它的cpu编号。没有理由不让一个进程在多个cpu上运行，但是linux可以使用processor_mask 将一个进程限制在一个或者多个cpu上。如果第N位被设置，那么cpu将只可以运行在处理器N上。当一个调度器选择了一个新的进程去执行的时候，它不会选择那些processor_mask中未标记允许在该cpu上运行的进程。调度器同时还会对上一次在该cpu上运行的进程有一些政策倾斜，因为这样可以避免上下文切换，提高效率。

4.4  Files






