
### Algorithm

https://leetcode.com/problems/climbing-stairs/

楼梯走法问题，把这一题单列出来，是因为非常有意义，在面试的时候居然遇到了这个问题。

面试当时居然我去推到公式，面试官说太慢了，给你点提示，你从最后一阶楼梯开始思考，到达最后一阶楼梯的方法有多少种？

带着这个提示推导出： f(n) = f(n-1) + f(n-2),熟悉的模样。

典型的动态规划，局部最优解，从一个节点的状态得到公式。

```
class Solution {
public:
    int climbStairs(int n) {
        if(n==1) return 1;
        if(n==2) return 2;
        int f1 = 1,f2 = 2,f3 = 0;
        for(int i = 2 ; i < n; i++)
        {
            f3 = f1 + f2;
            f1 = f2;
            f2 = f3;
        }
        return f3;
    }
};
```
### Review

https://www.tldp.org/LDP/tlk/kernel/processes.html

一篇关于进程的文章，看起来很全面，文章很长。这篇文章主要讲述了进程是什么以及在linx中进程是如何被创建、管理以及销毁的。

进程在操作系统中执行任务。一个程序就是一些列存储在磁盘上的机器代码指令和数据集合，因此它可以看成一个被动的实体。一个进程呢就可以看做是一个正在运行的程序。

进程是一个不断在变化的玩意，因为代码在不断的执行。一个进程不仅包含代码指令和数据，同时在一个进程栈中还有一些临时的数据比如参数，返回地址以及保存的变量。除了上面所说的，进程还包含着计数器和cpu寄存器。正在运行的程序或者说进程包含了所有微处理器中的活动。Linux 是一个多进程的操作系统，每个进程都是独立的，有他们自己的权限和任务。每个进程都在自己的虚拟地址空间中运行，因此他们在没有安全的内核保障机制下是不能够相互作用的。所以，一个进程挂掉之后，也不会影响到另外一个进程。

在一个进程多的生命周期中，它会用来很多的资源，诸如使用cpu资源来执行机器指令，使用内存来存储产生的数据。同时也会通过文件系统来打开文件，直接或者间接的打开其他设备。因为Linux是一个多进程的系统，所以为了避免单个进程过多的霸占CPU资源或者内存资源，Linux系统本身必须明确以及跟踪好自己的资源情况，这样能够协调好多个进程对资源的使用，起到公平公正的作用。

在一个多进程的操作系统中，CPU资源总是最珍贵的。因此，在多进程的任务中，如果CPU资源不够的情况下，没有获取CPU资源的进程就必须要等待。在这个等待的进程队列中，Linux使用调度器来决定下个该使用CPU资源的进程，调度器使用一系列的调度策略来确保进程的相对公平。

4.1 进程

Linux 管理着所有的它的进程，每个进程都有一个task_struct 结构体来表示。系统中用指针数组来存储所有的进程，这意味着Linux的进程是有限制的，它的大小是默认的512。每当一个进程被创建的时候，一个新的task_struct结构体被创建并且被添加到task队列，为了方便找到当前正在运行的进程，有一个
current的指针专门来记录正在运行的进程。

Linux不仅支持普通的进程也支持实时的进程。Linux调度器会对这些实时进程有更积极的策略。task_struct 结构体非常庞大和复杂，以下是一些字段以及功能：

State 描述进程的状态

Scheduling Information  调度信息，操作系统依据此信息进行调度

Identifiers 每个进程都有自己的标识符，标识符不是进程数组的下标，仅仅是一个数字，进程除了有自己的标识符外，还有用户标识符合用户组标识符，用来代码进程的访问权限

Inter-Process Communication 进程间通信

Links Linux下的进程都不是孤立存在的，除了init进程外，所有的进程都有一个父进程。新的进程并不是被创建出来的，而是被拷贝甚至是克隆出来的。每个进行用指针和它的父进程、兄弟进程以及子进程保持着联系。通常我们可以用pstree命令来看到进程间的关系
此外，所有的init进程的子进程和init进程都是双向链接的。这样有利于系统迅速找到所有的进程以支持类似与ps和kill的命令

Times and Timers 内核会一直跟踪中进程的创建时间以及进程在它的生命周期中消耗的cpu时间。每个时钟周期，Linux会更新每个进程所花费时间在用户态和内核态。
Linux同时指定间隔的定时器，进程可以通过调用系统函数来给自己设置定时器，这些定时器可以一次性设定，也可以间歇性设定。

File system 进行在按照它们的意愿打开文件的同时，在进程的结构体中会有指针指向这些文件的描述符以及另外的指针指向VFS的两个节点。每个VFS节点存储了文件或者目录在文件系统中唯一的描述符，并且提供了唯一的接口给下层的文件系统。

Virtual memory 绝大多数的线程有虚拟内存（内核线程和守护进程除外），内核必须记录虚拟内存和实际内存是如何对应的

Processor Specific Context 处理器的上下文切换，进程可以认为是系统当前状态的总和。无论何时，当一个进程在运行的时候，它会使用cpu寄存器、堆栈等。这就是进程的环境，当一个进程被挂起的时候，它此时的cpu环境信息将会被保存到进程结构体中，以便下次进程恢复执行时恢复该进程的环境

4.2  Identifiers 



