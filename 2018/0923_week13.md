
## Review

https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html

一篇介绍InnoDB行格式的文章。

行格式决定了行的物理存储，存储可以影响到查询和DML操作。当一个页中存储了更多的行，那么查询和索引就会更快，buffer pool中使用的内存就会更小，IO也会减少。

每个表都是有若干页组成的。每页的数据都是按照B-tree来组织存储的。表的数据和索引都是用这种结构。B-Tree索引存储表的所有数据的被称为聚簇索引，聚簇索引存储了表的所有行。二级索引存储的是索引本身和主键。

然而，变长列是个例外，变长的列有的长度太大而不适合存储到B-Tree page中，它们被存储到了overflow page中。这些列也被称为“off-page”列。
off page 列的值被存储在单链表中，每个列有其自己的一个或者多个溢出页链表。根据列的长度，所有的列值或者部分列值被存储到B-tree避免浪费空间，并且必须读单独的页。

Inodb 引擎支持四种格式，分别是REDUNDANT, COMPACT, DYNAMIC, and COMPRESSED.

### REDUNDANT Row Format

redundant 格式兼容早期版本的MySql。

这种格式的行会存储可变列的（varchar，varbinary，blob，text）前768个字节在B-tree节点中，而剩余的将会存储到溢出页上。定长的列大于768字节的将会被编码成为可变列。如果一个列的值小于等于768，溢出页不需要使用，并且这种情况下可以节省一些IO，因为所有的值都存储到B-tree节点中。当BLOB列值相对较短的时候，这工作的良好，但是可能会导致B-tree节点被数据填满而不是键值，这减少了效率。一个表中含有许多blob字段可能导致B-tree节点太满，并且包含的行太少，以至于索引效率下降相对于那些列值比较端切列值存储在off-page中。


### REDUNDANT Row Format Storage Characteristics

1 每个索引记录都包含6字节的头，这个header主要是为了连接连续的记录，并且为了实现行级锁。

2 聚簇索引包含用户定义的所有列，此外还有一个6字节的事务id字段和一个7字节的回滚指针字段。

3 如果没有定义主键，每个聚簇索引将包含一个6字节的行id

4 二级索引包含主键

5 记录包含一个指针指向记录的每行，如果列的总长度小于128字节，指针是一字节否则是俩字节。这些指针数组被称为记录目录。指针指向的地方即是数据存储的地方

6 定长的列存储固定的长度，varchar中尾随的空格不会被截断

7 定长的列超过768字节将会被编码为非定长列

8 null 占用一个字节或者俩个字节在记录目录中

变长列中，null不占用空间，定长列中占用固定的长度，但是列从null变为非null时，不会引起索引碎片化


### COMPACT Row Format

compact 行格式相对于 redundant 格式节省了20%的磁盘空间，但是在一些操作上增加了cpu的使用。如果你的服务器受限于缓存命中或者磁盘速度，那么compact 格式的似乎会快一些，但是如果你的服务器受限于cpu，那么compact就会慢一些。

使用compac格式存储的表，变长的字段将会存储前768个字节，剩余的部分将会存储在overflow pages。定长的字段大于等于768字节的将会被编码为可变列。

列的长度小于等于768字节的将不会使用overfolw page，所有的列都存在了b+树节点上，一定程度上节省了磁盘，特别对一些短的blob字段比较适合，但是也要注意，一个表如果有多个这样的blob字段的时候，b+树上的节点会被这些数据充满，导致一个行上存不了太多的行这样会使索引相对不高效相对于哪些比较短的列或者使用了overflow page的列。

### COMPACT Row Format Storage Characteristics

1 每个索引记录会有5比特的字节长的头，用来链接连续的行和用于行级🔒

2 变长头部分存储着为null的字节向量，字节为null的列不占用可变头部以外的空间。如果所有列都是not null 并且有定长，那么将不会有可变长部分




