### Algorithm

617. Merge Two Binary Trees

https://leetcode.com/problemset/all/?listId=79h8rn6

题目： 合并两个二叉树，相同位置的节点进行求和。

分析：直观感觉应该使用递归，然后就直奔递归去了，中间错了两次，终于完成了这个非常low的递归解法，不过自己独立完成的，感觉还是有一点点小开心，经过上次的
递归解法，根据自己的小demo，对递归有了基础的掌握。

我的想法是以左边树为基础，然后把右边的树合并到左边的树上。所以，如果左边树的节点是否为空就是判断点。
左边树的节点是空的话，就不需要递归了，直接赋值右边的节点。
两边都有值的，进行递归处理。

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if(t1 && t2)
        {
            t1->val  = t1->val + t2->val;
            
             if(t1->left && t2->left)
            {
                mergeTrees(t1->left,t2->left);
            }
        
            if(t1->right && t2->right)
            {
                mergeTrees(t1->right,t2->right);
            }

            if(!t1->left && t2->left)
            {
                t1->left = t2->left;
            }

            if(!t1->right && t2->right)
            {
               t1->right = t2->right;
            }       
              
        }
        if(!t1 && t2)
        {
            t1 = t2;
        }      
        return t1;
            
    }
};

```
