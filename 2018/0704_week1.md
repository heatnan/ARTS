
### Algorithm

leetcode 20. Valid Parentheses

problem: 给你一个只包含 '(', ')', '{', '}', '[' , ']' 字符的字符串，判断这个字符串是否合乎规则.

eg: {()[]{}} is true ,{]}() is false

分析:

这题实际上我就难住了，刚开始我想统计每对符号出现次数的求和，然后看下是否是偶数，但是这样对没办法对顺序进行校验。
这题在我读大学的时候遇到过，仿佛记得是用栈，但是全部压入后，也没办法匹配啊！

最后还是忍不住看了讨论区，承认这个习惯是很不好的。

确实很巧妙，对于 {()[]{}} 这样的匹配，最好是从 右括号开始匹配，因为右括号出现的越早，说明他覆盖的范围是越小的，这样找到一个最小的括号范围然后消掉这对括号就可以了。然后继续找右括号，与前面的左括号匹配，如果发现左括号不匹配那说明格式是不对的。

```C++
bool isValid(string s) {
        std::stack<char> temp;
        for(int i =0;i<s.length();i++)
        {
            switch(s.at(i))
            {
                case '[':
                case '{':
                case '(':
                    {
                        temp.push(s.at(i));
                        break;
                    }
                case ']':
                    {
                        if( temp.empty()  || temp.top() != '[') 
                            return false;
                        else
                            temp.pop();
                        break;
                    }
                 case '}':
                    {
                        if( temp.empty()  || temp.top() != '{') 
                            return false;
                        else
                            temp.pop();
                        break;
                    }
                 case ')':
                    {
                        if( temp.empty()  || temp.top() != '(') 
                            return false;
                        else
                            temp.pop();
                        break;
                    }
            }
        }
        
        return temp.empty();
        
    }


```


### Review
review 阅读并点评一篇文章
https://thispointer.com/c11-how-to-stop-or-terminate-a-thread/

一篇文章至少能有一个地方让你弄明白一个点，我觉得就是好文章。其中这一篇就是好文章：
因为让我明白了为什么不能直接的把线程给终止掉。

主要源于你关闭的线程可能还有资源要释放或者关闭。

* 如果这个线程正在持有一个锁，那么直接把这个线程干了，谁来释放这个锁？
* 如果这个线程已经开启了一个文件，正在写进文件，直接把他干了，谁来关闭这个文件？
* 如果这个线程动态的分配了内存，那么直接干了，谁来回收？

接着，作者介绍了关闭线程的正确姿势，使用std::future<void> .



### Tip
建立的crontab没有运行，如何进行排查？
参考文章：
https://serverfault.com/questions/449651/why-is-my-crontab-not-working-and-how-can-i-troubleshoot-it

最近，用crontab在一个脚本中执行了一个php，但是没有运行，经过google和重启了一次crontab终于算是搞定了。

简单记录下crontab 没有运行的检查思路：

1. 确认crontab是开启的
2. 脚本中使用php执行的时候，最好写全php的路径
3. php中的文件引用最好使用绝对路径
4. 捕获crontab执行的错误信息到一个文件

不过仍然让我感到不解的是，最开始我查看了crontab确实是运行的，而且上面的路径我都处理好了，但是仍然没有运行，当我重启一次crontab后，自动好了，费解。


### Share

Share 分享一篇有观点的文章，参考了耗子叔推荐的一个链接：https://www.percona.com/blog/2009/08/06/why-you-dont-want-to-shard/

是关于mysql分区一篇文章，作者说他们很少在workshop分享关于分区的话题，原因是："你们并不想分区"。

作者首先阐述了想要分区的动机： 
1. 数据集太大了，一台单机内存不足于加载数据 
2. 写太多，IO或者从库总有一个会跟不上。

尽管作者不太情愿分区，但是还是给出了坚持分区的小伙们一些方法：

1. 按照应用分区，这个意思是找出使用最频繁的几个表，然后将他们分配到新的mysql server上。
2. 按照hash或者key去区分，选择一个列，然后根据这个列去分割表，但是最重要的是保证分割后的表大小差不多。
但这个平均的算法很难设计。
3.根据查询server分区，这个实现依赖于一些按照规则设计好的服务器，当被查询的时候会首先询问这个数据存在于那台服务器，
这是一个搞扩展性的设计，但是如何设计这个规则保证各个服务器上的访问量是差不多的，是很复杂的。

作者说了，很多复杂，最后解释下他认为复杂的原因：

1. 工程师必须要写更多的代码来维护这个分区逻辑，但是诸如HiveDB就会简单很多
2. 操作问题将会变得更加困难，诸如备份、修改表结构等

大部分人可能更关注第一点，但是第二点在升级的时候需要做很多工作才能让所有的节点保持一致，才能正确运行，第二点才是最酸爽的。

